function e(e,r,n){const{__name:a,__primaryKey:t}=e;return{__name:a,__primaryKey:t,__has:r,__alias:n}}function r(r,n,a){var t;const i=Object.assign(Object.assign({},n),{__name:r,__primaryKey:null!==(t=null==a?void 0:a.primaryKey)&&void 0!==t?t:"id",__relationship:{}});return Object.setPrototypeOf(i,{hasOne(r,n){const a=this,t=null!=n?n:r.__name,i=Object.entries(a.__relationship).find((([e,n])=>n.__name===r.__name));if(i&&a.__relationship[i[0]].__primaryKey===r.__primaryKey&&r.__primaryKey===a.__name)throw new Error(`"${r.__name}" reference already exists in "${a.__name}" as "${i[0]}" with the primary key (pk) "${r.__primaryKey}". "${a.__name}" table failed to create a hasOne relationship with "${t}" because it has the same primary key "${r.__primaryKey}" as "${i[0]}". The primary key for "${i[0]}" and "${t}" are not unique.`);return a[t]="hasOne",a.__relationship[t]=e(r,"hasOne",t),this},hasMany(r,n){const a=this,t=null!=n?n:r.__name,i=Object.entries(a.__relationship).find((([e,n])=>n.__name===r.__name));if(i&&a.__relationship[i[0]].__primaryKey===r.__primaryKey&&r.__primaryKey===a.__name)throw new Error(`"${r.__name}" reference already exists in "${a.__name}" as "${i[0]}" with the primary key (pk) "${r.__primaryKey}". "${a.__name}" table failed to create a hasOne relationship with "${t}" because it has the same primary key "${r.__primaryKey}" as "${i[0]}". The primary key for "${i[0]}" and "${t}" are not unique.`);return a[t]="hasMany",a.__relationship[t]=e(r,"hasMany",t),this}}),i}function n(e,r){return{__name:e,__objects:r.map((e=>e.__name))}}function a(e,r){for(const[n,a]of Object.entries(e))if(r[n]!==a)return!1;return!0}function t(e,r,n){const a={};function t(e){e.forEach((e=>{const t=n[e],i=r.__relationship[e];return i?"hasOne"===i.__has?a[e]=t[i.__primaryKey]:void(a[e]=t.map((e=>e[i.__primaryKey]))):a[e]=t}))}return t("*"===e?Object.keys(n):e),a}function i(e,r,n){const{from:s,where:_,fields:y,join:p}=n;if(Array.isArray(_))return _.flatMap((a=>i(e,r,Object.assign(Object.assign({},n),{where:a}))));let m=null;const c=e[s],l=r[s];if("*"===_&&(m=Object.values(l).map((e=>t(y,c,e)))),"object"==typeof _){const e=_[c.__primaryKey];if(e&&(m=t(y,c,l[e])),!e){m=[];for(const[e,r]of Object.entries(l)){a(_,r)&&m.push(t(y,c,r))}}}if("function"==typeof _){m=[];for(const[e,r]of Object.entries(l)){_(r)&&m.push(t(y,c,r))}}if(m&&p){const n=Array.isArray(m);n&&m.forEach((n=>{o(n,{join:p,from:s,model:e,state:r})})),n||o(m,{join:p,from:s,model:e,state:r})}return m}function o(e,r){const{join:n,from:a,model:t,state:s}=r,_=t[a];n.forEach((({on:r,fields:n,join:y})=>{if(e[r]){if(!_.__relationship[r])throw new Error(`Field "${r}" does not exist in object "${a}"`);if("hasOne"===_.__relationship[r].__has&&(e[r]=i(t,s,{fields:n,from:_.__relationship[r].__name,where:{[_.__relationship[r].__primaryKey]:e[r]}})),"hasMany"===_.__relationship[r].__has){const a=[];e[r].forEach((e=>{const o=i(t,s,{fields:n,from:_.__relationship[r].__name,where:{[_.__relationship[r].__primaryKey]:e}});o&&a.push(o)})),e[r]=a}y&&o(e[r],{from:_.__relationship[r].__name,join:y,model:t,state:s})}}))}function s(e){const{relationalCreators:r,indexes:n,identifier:a}=e,t={},o=new Set,s=r.reduce(((e,r)=>{var n,a;const t=function(e,r){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&r.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var t=0;for(a=Object.getOwnPropertySymbols(e);t<a.length;t++)r.indexOf(a[t])<0&&Object.prototype.propertyIsEnumerable.call(e,a[t])&&(n[a[t]]=e[a[t]])}return n}(r,["hasOne","hasMany"]);if(!t[null!==(a=null===(n=t.__relationship[t.__primaryKey])||void 0===n?void 0:n.__name)&&void 0!==a?a:t.__primaryKey])throw new Error(`The table "${t.__name}" does not have a primary key (pk) "${r.__primaryKey}", pk should be listed here ${JSON.stringify(r)}`);return Object.assign(Object.assign({},e),{[t.__name]:t})}),{});return null==n||n.forEach((e=>s[e.__name]=e)),{state:t,select:function(e){return i(s,t,e)},selectIndex:function(e,r){const n=t[e],a=[];return n.index.forEach((o=>{const _=n.objects[o],y=r[_.name];if(!y)throw new Error(`selectIndex() expected SelectOptions for "${_.name}" in the index "${e}".`);const p=i(s,t,Object.assign(Object.assign({},y),{where:{[_.primaryKey]:_.primaryKeyValue}}));if(!y.where)return a.push(p);y.where(p)&&a.push(p)})),a},upsert:function(e,r){var n;const i=Array.isArray(e)?e:[e],_=(null!==(n=null==r?void 0:r.indexes)&&void 0!==n?n:[]).map((e=>s[e]));function y(e){const{name:r,item:n,parentName:a,primaryKey:i,parentPrimaryKey:o,relationalObject:s}=e,_=Object.values(s.__relationship).find((e=>e.__name===a));if(_&&("hasOne"===_.__has&&(t[r][n[i]][_.__alias]=t[a][o]),"hasMany"===_.__has)){const e=t[r][n[i]][_.__alias],s=t[a][o],y=Array.isArray(e);if(y||(t[r][n[i]][_.__alias]=[s]),y){!!e.find((e=>e[i]===s[i]))||e.push(s)}}}function p(e){const{item:r,parentName:n,parentField:i,parentFieldHasMany:o,parentPrimaryKey:m}=e,c=function(e){for(const r in a)if(Object.prototype.hasOwnProperty.call(a,r)&&(0,a[r])(e))return r;throw new Error(`Identifier was not able to identify this object ${JSON.stringify(e)}`)}(r),l=s[c],h=l.__primaryKey;if(!r[h])throw new Error(`Expected object "${c}" to have a primaryKey "${h}".`);if(t[c]||(t[c]={}),t[c][r[h]]||(t[c][r[h]]={}),_.forEach((e=>{if(!e.__objects.includes(c))return;t[e.__name]||(t[e.__name]={index:[],objects:{}});const n=`${c}-${r[h]}`;t[e.__name].objects[n]||(t[e.__name].index.push(n),t[e.__name].objects[n]={name:c,primaryKey:h,primaryKeyValue:r[h]})})),Object.entries(r).forEach((([e,n])=>{if(l.__relationship[e]){return"hasMany"===l[e]?void r[e].forEach((n=>{p({item:n,parentPrimaryKey:r[h],parentField:e,parentName:c,parentFieldHasMany:!0})})):void p({item:r[e],parentPrimaryKey:r[h],parentField:e,parentName:c})}t[c][r[h]][e]=n})),n&&i&&m){if(o){const e=t[n][m][i],a=t[c][r[h]];if(!Array.isArray(e))return t[n][m][i]=[a],void y({name:c,item:r,parentName:n,parentPrimaryKey:m,primaryKey:h,relationalObject:l});return void(!!e.find((e=>e[h]===a[h]))||(e.push(a),y({name:c,item:r,parentName:n,parentPrimaryKey:m,primaryKey:h,relationalObject:l})))}y({name:c,item:r,parentName:n,parentPrimaryKey:m,primaryKey:h,relationalObject:l}),t[n][m][i]=t[c][r[h]]}}i.forEach((e=>p({item:e}))),o.forEach((e=>e()))},subscribe:function(e){return o.add(e),()=>o.delete(e)}}}"function"==typeof SuppressedError&&SuppressedError;export{r as createRelationalObject,n as createRelationalObjectIndex,s as createStore};
//# sourceMappingURL=index.esm.js.map
